<?xml version="1.0" encoding="us-ascii"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.28 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-thomson-xmpp-secure" category="std">

  <front>
    <title abbrev="Secure Messaging in XMPP">Secure Messaging in XMPP</title>

    <author initials="M." surname="Thomson" fullname="Martin Thomson">
      <organization>Mozilla</organization>
      <address>
        <postal>
          <street>\</street>
          <city>Mountain View, CA</city>
          <country>US</country>
        </postal>
        <phone>+1 650 903 0800</phone>
        <email>martin.thomson@gmail.com</email>
      </address>
    </author>
    <author initials="A.B." surname="Roach" fullname="Adam Roach">
      <organization>Mozilla</organization>
      <address>
        <postal>
          <street>\</street>
          <city>Dallas</city>
          <country>US</country>
        </postal>
        <phone>+1 650 903 0800 x863</phone>
        <email>adam@nostrum.com</email>
      </address>
    </author>

    <date year="2015" month="June" day="09"/>

    
    
    

    <abstract>


<t>The history of secure messaging in XMPP is spotty. The long-running de facto scheme, OTR, enjoys fairly wide implementation and use, but OTR suffers from some serious usability and security shortcomings that make it unsuitable as a basis for encryption.</t>

<t>This describes an architecture that provides end-to-end confidentiality and integrity for XMPP messaging. Solutions for both multi-user and one-to-one messaging are provided.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>The history of secure messaging in XMPP is spotty. The long-running de facto scheme, OTR, enjoys fairly wide implementation and use, but OTR suffers from some serious usability and security shortcomings that make it unsuitable as a basis for encryption.</t>

<t>This describes an architecture that provides end-to-end confidentiality and integrity for XMPP messaging. Solutions for both multi-user and one-to-one messaging are provided.</t>

</section>
<section anchor="goals" title="Goals">

<t>This is a very simple proposition with a somewhat involved solution:</t>

<t><list style="symbols">
  <t>one-to-one messaging is secured end-to-end</t>
  <t>multi-user chats are secured end-to-end</t>
  <t>messages can be sent to offline users</t>
  <t>the set of entities that can decrypt a message can be audited</t>
  <t>users are able to control whether their communications can be correlated across different venues</t>
</list></t>

</section>
<section anchor="architectural-overview" title="Architectural Overview">

<t>This system aims to achieve the above goals by adding encryption to chat-related XMPP functions.</t>

<t>This only aims to protect chat-related messaging. It provides only limited protection for presence information.  The key agreement parts of this protocol are intended to be generically applicable, but the application to file transfer, jingle, and myriad other XMPP features is left for future efforts.</t>

<section anchor="the-new-pieces" title="The New Pieces">

<t>Encrypting a message is rather straightforward once the symmetric encryption key is chosen. <xref target="heading=h.ktgjevro0of4">Message encryption</xref> is the first building block.</t>

<t>Establishing the key used in message encryption is more difficult. This design uses a scheme whereby <xref target="heading=h.bn30rom3o54">encryption keys are advertised</xref> prior to use. How this is done varies only slightly between one-to-one messaging and MUC.</t>

<t>Ensuring proper key distribution to a potentially large and changing set of users is the most challenging and involved piece of infrastructure to design and build. This architecture uses a <xref target="heading=h.8g20p7ezhqt3">secure roster</xref> that makes and verifies strong cryptographic assertions about participation.</t>

<t>Pseudonymity functions allow a user to safeguard their privacy. The addition of strong cryptography makes it easier for passive observers to correlate activity, but <xref target="heading=h.lxiw92co95y4">pseudonymity</xref> allows users to minimize what information about their activity is leaked to others.  <xref target="heading=h.9var2wwipg3">Identity assertions</xref> allow users to strongly authenticate others.</t>

</section>
<section anchor="one-to-one-messaging" title="One-to-One Messaging">

<t>Message encryption for one-to-one messaging uses a unilateral key declaration for key management.</t>

<section anchor="publishing-key-exchange-data" title="Publishing Key Exchange Data">

<t>Clients that wish to participate in encrypted messaging publish keying material to their presence.  This includes a signing public key that is used to authenticate messages and a Diffie-Hellman (DH) share used for exchanging the symmetric keys used in encryption. Each client generates new keying material that is bound to the full JID that they use. Keying material is published under a randomly generated key identifier.</t>

<t>New clients can only be added if an existing client attests to the addition. This is intended to stop a subverted server from adding clients. This uses a form of the same <xref target="heading=h.7ealuqgrad2o">roster log</xref> that is used for multi-party chats. (Issue: does this represent a UX issue? Not much if we subscribe to the principal device theory (NOTE:  The principal device here is a smartphone.  That device goes with users everywhere and can serve as an anchor for security operations, like adding a new client to the set of authorized clients for a JID.).)</t>

</section>
<section anchor="establishing-pairwise-keying-material" title="Establishing Pairwise Keying Material">

<t>Prior to sending a message, a client first retrieves and validates the presence of the intended recipient. A client that supports encryption will have a valid DH share.</t>

<t>The sending client then generates new symmetric keys that it will use with this peer.  This key is enciphered toward all the clients in the recipient’s presence.</t>

<t>The key is also enciphered toward other authorized clients for the sender’s JID. This allows other clients to decipher the messages that other clients have sent.  It also allows those clients to reuse the key.</t>

<t>It is also necessary for clients to update this information if a client is added by sender or recipient. Otherwise, clients that reuse symmetric keys will generate messages that new clients are unable to decrypt.</t>

</section>
<section anchor="message-encryption" title="Message Encryption">

<t>Once keying material has been selected or new keying material has been advertised, messages are <xref target="heading=h.d2pubehigub">encrypted and decrypted</xref> using that symmetric key.</t>

<t>Recipients of the message recover the advertised keying material by retrieving the presence of the sender and decrypting the enciphered key.</t>

</section>
</section>
<section anchor="multi-user-chat" title="Multi-User Chat">

<t>A user founds a MUC in <eref target="http://xmpp.org/extensions/xep-0045.html#createroom">the usual fashion</eref>. Two changes are made:</t>

<t><list style="numbers">
  <t>The client creates a temporary JID that is unique for the room, and matching keying material that it will use exclusively with that temporary JID.</t>
  <t>The message that founds the room includes a founding entry for the <xref target="heading=h.7ealuqgrad2o">secure roster log</xref> for the room.  This is an element that establishes the creating user as an owner in a manner that can be independently verified.</t>
</list></t>

<t>All subsequent changes to the roster of the MUC need to be accompanied by a message that authorizes the change.  This message is signed by the user that proposes the change. All users verify the resulting series of changes that accumulate to build up the room roster.</t>

<section anchor="unauthorized-changes-to-the-roster-are-therefore-detectable-keying-material-is-only-shared-with-users-that-have-been-legitimately-added-to-the-roster" title="Unauthorized changes to the roster are therefore detectable. Keying material is only shared with users that have been legitimately added to the roster.">

</section>
<section anchor="inviting-other-clients" title="Inviting Other Clients">

<t>In order to invite a user to a chat, two pieces of identifying information for the invited client needs to be retrieved: a temporary JID and the keying material for that client.</t>

<t>This is complicated by the fact that clients can be—and frequently are—offline.  In the initial request for an alias, the client that is initiating the invitation receives presence for the new alias that does not include keying material.</t>

<t>In this case, the inviting client generates a signed invitation and sends this to the bare JID of the offline user. This invitation is a bearer token that can be exercised by any client that has it.  The invitation must be encrypted using one-to-one message encryption, or servers can steal and use it. A user with the bearer token includes that in a signed roster log entry when they join the room. The room adds the entry to the roster log if it can be validated.</t>

<t>The use of a signed invitation is less deterministic than the online invitation method, because the addition is attested directly by the client that is adding the user. It can also be more expensive to validate. That said, it might be prudent to remove the online option just to remove complexity.</t>

</section>
</section>
</section>
<section anchor="message-encryption-details" title="Message Encryption Details">

<t>A simple combination of symmetric encryption and asymmetric signing are used to protect messages.</t>

<t>This wrapping scheme takes an unencrypted, serialized XMPP stanza. The process adds a signature over this data. Then the signed content is encrypted.</t>

<t>content = cleartext || sender.sign(cleartext)
ciphertext = encrypt(keys{keyid}.key, nonce, content)</t>

<t>The routing and message handling information from the cleartext (element basename plus to, from, and type attributes) is added to a new stanza of the same basename as the original. That is, &lt;iq&gt; stanzas produce encrypted &lt;iq&gt; stanzas; &lt;message&gt; stanzas result in encrypted &lt;message&gt; stanzas.  Unfortunately, these attributes govern message delivery in ways that could cause compatibility issues if they were encrypted.</t>

<t>ISSUE: The potential variations in these values leaks information; a future study might identify mappings that allow for reductions in this leakage.  This might include identifying cases where removing the resource identifier from routing attributes is safe; or finding ways to map the range of stanza elements and type attributes to a reduced set.  If there was a consistent set of policies with respect to handling the different stanzas and types, this would be easier.</t>

<t>A new &lt;e&gt; element is added to the encrypted element.  The content of this element is a base64 encoded string that contains the encrypted message.</t>

<t>This element includes attributes for a <xref target="heading=h.mlllqldqlir2">key identifier</xref> and sequence number. The key identifier provides the information a recipient needs to decrypt the message. The sequence number increases by one for every message sent, allowing a receiver to detect when messages are dropped or lost.</t>

<section anchor="encapsulation" title="Encapsulation">

<t>Encrypted messages always use either the &lt;message&gt; stanza or the &lt;iq&gt; stanza based solely on the nature of the exchange. Messages that require a response from a specific client use the &lt;iq&gt; stanza; all other messages use &lt;message&gt;.</t>

<t>Presence information can be encrypted, but this is necessarily mixed with unencrypted data. An extension to the &lt;presence&gt; element includes confidential presence information. Note that presence information is effectively broadcast; but any encrypted information will need a limited audience, and all that audience will need to receive the same encryption key.</t>

</section>
<section anchor="for-example-the-following-message-from-rfc-6121httpstoolsietforghtmlrfc6121section-521" title="For example, the following message from :"><eref target="https://tools.ietf.org/html/rfc6121#section-5.2.1">RFC 6121</eref>

</section>
<section anchor="ltmessage" title="&lt;message">
<figure><artwork><![CDATA[
from='juliet@example.com/balcony'
id='ktx72v49'
to='romeo@example.net'
type='chat'
xml:lang='en'>   &lt;body>Art thou not Romeo, and a Montague?&lt;/body> &lt;/message>
]]></artwork></figure>

</section>
<section anchor="might-be-encrypted-into-a-message-of-the-form" title="Might be encrypted into a message of the form:">

</section>
<section anchor="ltmessage-1" title="&lt;message">
<figure><artwork><![CDATA[
from='juliet@example.com/balcony'
id='ktx72v49'
to='romeo@example.net'
type='chat'>   &lt;e xmlns=’...tbd...’ key=’MSPw9g5tlj9BZGF6’ seqno=’1’>
Ume+BIoftGYSA2Z2yJMyycNvMJmpysdfQY2wcrCiK0AtsrqWZR6KcTTEkewfepW
1FGIYpmZFLGSybwRZ+VcOHdlOl9aYVzdSPDmXrM2mrJGhz7sxphlKfPlw6ZrJ7Dt
Gq9IM0epBu6E4hb9DDb4+ORR2Ap7+cAD+ICMJQMySuq/mVE7ybxxWzloU30Lb
Gn/lzU9cmUww3yCI98WZAcHoeTQXJ0b/qjUpqYjJwCshaCH_HH7daks0TS3IojH
OancJmsBd5RYqMHekrpD9RpuWGGzR-ro0ScRbdsLnzXmYl62qSnyw1qCMNuJE
5o5_uraBRgEkCDlXas   &lt;/e> &lt;/message>
]]></artwork></figure>

</section>
<section anchor="this-removes-the-language-indicator-from-the-unencrypted-stanza" title="This removes the language indicator from the unencrypted stanza.">

</section>
<section anchor="symmetric-encryption" title="Symmetric Encryption">

<t><eref target="https://tools.ietf.org/html/rfc5116">Authenticated Encryption with Additional Data (AEAD)</eref> is used to provide confidentiality of messages, as well as integrity against unauthorized recipients.</t>

<t>The AEAD key is either <xref target="heading=h.innzefuq4dlz">advertised</xref> or reused from a prior advertisement. The advertisement of the key establishes the scheme that is used.</t>

<section anchor="nonces" title="Nonces">

<t>The sequence number on each message determines the nonce that is used with the AEAD. For a given combination of sender and key identifier, sequence numbers cannot repeat without risking compromise of the confidentiality and integrity provided by authenticated encryption. The following nonce derivation method is used:</t>

<t>nonce = <eref target="https://tools.ietf.org/html/rfc5869">HKDF</eref>(0, sender.fullJID, ‘nonce’, N_MAX) ⊻ seqno</t>

<t>This nonce selection ensures a negligible probability of nonce reuse as long as each sender correctly increments the sequence number. Recipients can verify that sequence numbers are not reused.</t>

</section>
<section anchor="symmetric-algorithm-agility" title="Symmetric Algorithm Agility">

<t>Key identifiers also identify the AEAD algorithm that is used to encipher a message.  That information is carried in the key advertisement.</t>

<t>Messages may be enciphered multiple times with different keys.  This allows new encryption schemes to be deployed, at the cost of sending some messages multiple times. This is only necessary if some potential recipients only support old AEAD algorithms.</t>

<t>This presents a downgrade attack vector if an attacker can convince a sender that a legitimate client supports a weaker cipher suite.</t>

</section>
</section>
<section anchor="signature" title="Signature">

<t>A signature on messages is necessary to prevent impersonation of other MUC participants. This means that repudiation of the form that OTR claims to provide is not offered, because that requirement is incompatible.  Note however that a temporary MUC using <xref target="heading=h.lxiw92co95y4">a temporary JID</xref> and no <xref target="heading=h.9var2wwipg3">identity assertion</xref> provides only circumstantial means of attributing activity to a user.</t>

</section>
<section anchor="decryption-and-validation" title="Decryption and Validation">

<t>The reverse of this process is used to decrypt messages. Encrypted information is authenticated and the signature validated. The decrypted and verified stanza is then parsed as though it were in place of the current stanza.</t>

<t>A client only needs to decrypt one &lt;e&gt; element, since each is required to include the same content. All unencrypted content in the stanza is removed and consequently ignored.</t>

<t>It is important that the receiver check that the stanza is whole and valid before allowing it to be processed further. A server that is unable to decrypt a message cannot be relied upon to ensure that messages are valid.</t>

<t>In the cleartext protocol, framing issues do not propagate easily, since they directly affect stanza processing. Encrypted stanzas allow a malicious peer to generate invalid—especially unterminated—XML. Extraneous bogus frames resulting from unchecked XML might be exploited to impersonate a server toward a receiving client. Matching the enciphered <spanx style="strong">from</spanx> attribute against the included signature is also necessary to prevent other forms of impersonation.</t>

<t>Additional checks might be necessary for specific stanzas, types, or content. In general, any checks that might have been possible on a server need to be carried out by clients that received encrypted stanzas.</t>

</section>
<section anchor="presence-encryption" title="Presence Encryption">

<t>Some presence information might be confidential.  For instance, many users include a status message that is shared with their friends. Encrypting status is highly desirable.</t>

<t>Direct children of the presence stanza may be encrypted in an &lt;e&gt; element. These necessarily use a different key than those used for other types of messaging to avoid problems with controlling key disclosure.</t>

</section>
<section anchor="chat-state-notifications" title="Chat State Notifications">

<t>Clients are required to encrypt <eref target="https://xmpp.org/extensions/xep-0085.html">chat state notifications</eref>.  However, these messages are useless to an offline client.  A server that can see these messages is <eref target="http://xmpp.org/extensions/xep-0160.html#types">required to drop them</eref>, but encrypted messages can’t be distinguished from other more important messages.</t>

<t>Thus, clients are required to suppress chat state notifications when a peer is offline.</t>

</section>
<section anchor="layers-of-encryption" title="Layers of Encryption">

<t>A group chat might use one-to-one message encryption to send messages to a user. There’s a question about what advantage that provides.  Removing the nick from messages might be of some advantage, but that advantage is better managed with <xref target="heading=h.9var2wwipg3">pseudonymity</xref>.</t>

</section>
</section>
<section anchor="key-advertisement" title="Key Advertisement">

<t>Users publish the encryption keys that they use for one-to-one messaging to their presence. In an MUC, this is the presence that they advertise to the room.</t>

<section anchor="asymmetric-key-advertisement" title="Asymmetric Key Advertisement">

<t>Two forms of asymmetric keys are used by clients: a signing key that is used to authenticate all forms of messages sent by that client, and a Diffie-Hellman (likely elliptic curve) share that is used in symmetric key advertisements.</t>

<t>Asymmetric keys are added to the <xref target="heading=h.twitjc1mwopy">roster log</xref> maintained for each user or MUC.</t>

</section>
<section anchor="symmetric-key-advertisement" title="Symmetric Key Advertisement">

<t>A key advertisement contains the following information:</t>

<t><list style="symbols">
  <t>A key identifier</t>
  <t>An encryption scheme identifier</t>
  <t>The full JID of the advertising client</t>
  <t>The full JID of the key recipient</t>
  <t>A key identifier for the DH share for the advertising client</t>
  <t>A key identifier for the DH share for the key recipient</t>
  <t>A symmetric key, encrypted using a key derived from the DH exchange</t>
  <t>An expiration date and time, after which the key must not be used</t>
  <t>A key identifier for the signing key</t>
  <t>A signature over this entire structure</t>
</list></t>

<t>Rather than use key identifiers for DH shares it might be easier to exchange the share itself, since that is unambiguous and likely not significantly different in size.  That makes the advertisement self-contained. Note that this would not absolve the key recipient of the need to check that the DH share (or signature key) is from a valid and authorized entity. The use of a key identifier makes that check implicit and avoids some types of mistake.</t>

<t>The signature is required to ensure that a key is not replayed and consequently reused.</t>

<t>A complete key advertisement includes the same information repeated for each recipient. Common information, and the signature, don’t need to be repeated. A single signature has implications for key lifetime.</t>

</section>
<section anchor="key-identifiers" title="Key Identifiers">

<t>Key identifiers are used to select the key that is used for encryption and decryption. Each key advertisement has an associated key identifier.</t>

<t>Care needs to be taken to ensure that key identifiers are unique within the context that they are created. Since keys are proposed and used by multiple actors without synchronization, identifying keys with a large identifier (such as a GUID) is advised.</t>

</section>
<section anchor="key-lifetime" title="Key Lifetime">

<t>Keys are advertised with an expiration time that limits the time when they can be used for encryption. However, offline clients need to be able to read messages that are generated while they are offline. Clients that are offline for extended periods need to be able to recover the keys that were used to encrypt those messages.</t>

<t>Keys advertised to user presence are therefore persisted until their intended recipients have retrieved and acknowledged keys. Since each key is encrypted toward a specific client, once that client retrieves the key it can be removed, though explicit acknowledgment might be desirable. Note that the set of recipients includes all client instances of the intended recipient, plus all client instances of the sender.</t>

<t>Once the complete set of potential recipients have acknowledged a key, then it can be removed.  This might use implicit acknowledgment for client instances of the sender, since the server can track message delivery to those clients. Explicit acknowledgment is necessary for remote clients of the recipient.</t>

<t>Keys advertised within an MUC enter the chat transcript.  New messages to the chat are expected to use the latest key, so old keys only need to be maintained to account for race conditions where messages might be sent without knowledge of the most recent key. Keys that are superseded by a newer key can therefore be disposed of after a short duration.</t>

<t>Here, the ordering of messages to the MUC is used to determine which key is used. That ordering allows clients to remove and discard older keys.</t>

</section>
</section>
<section anchor="user-and-muc-rosters" title="User and MUC Rosters">

<t>All efforts to encipher messages are largely pointless if the architecture permits servers to add themselves to the set of clients and thereby acquire keying material. The roster of clients that are authorized to represent a user, or which are part of an MUC, is a resource that needs strong integrity protection to prevent a malicious server from becoming part of conversations.</t>

<t>The canonical form of each roster takes the form of a log. A roster log is a verifiable chain of changes to the roster. The log can be validated by any entity and the set of participants validated.</t>

<t>Each entry in the log identifies the entry that immediately precedes it by including a cryptographic hash of that entry.  This ensures that a valid log cannot include divergent or conflicting changes (this does not prevent <xref target="heading=h.b8kmdxburaor">certain forms of manipulation</xref> by servers). Each entry is signed by the entity that generated the entry, allowing changes to be attributed and validated.</t>

<t>A successfully validated roster log can be used by a client to determine the set of clients that a <xref target="heading=h.evfc2c8bg0h9">key advertisement</xref> needs to be enciphered toward. In ensuring that a validated roster log is used prior to advertising new keys, clients can ensure that only authorized clients receive those keys.</t>

<section anchor="roster-entries" title="Roster Entries">

<t>There are several types of entry that can be recorded into the roster log. The following table summarizes the different types of log entry.</t>

<t>&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;Entry Type&lt;/td&gt;
    &lt;td&gt;Parameters&lt;/td&gt;
    &lt;td&gt;Who can add it&lt;/td&gt;
    &lt;td&gt;Notes&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Set Room Type&lt;/td&gt;
    &lt;td&gt;Room Owner,
Room Type&lt;/td&gt;
    &lt;td&gt;Room Owner&lt;/td&gt;
    &lt;td&gt;This entry must be the first entry in a MUC roster log. This also establishes the signer as a room owner. (MUC only)&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Set Room Permissions&lt;/td&gt;
    &lt;td&gt;Permissions&lt;/td&gt;
    &lt;td&gt;Room Owner&lt;/td&gt;
    &lt;td&gt;The set of permissions are taken from XEP-0045, limited to those that can change. (MUC only)&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Set Affiliation&lt;/td&gt;
    &lt;td&gt;Subject,
Affiliation&lt;/td&gt;
    &lt;td&gt;Authorized Client&lt;/td&gt;
    &lt;td&gt;The maximum role that the subject can assume might be included, or it might be determined based on affiliation. (MUC only)&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Set Client State&lt;/td&gt;
    &lt;td&gt;Subject,
State&lt;/td&gt;
    &lt;td&gt;Authorized Client&lt;/td&gt;
    &lt;td&gt;This determines whether the identified client is authorized or not. (One-to-one only)&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Redeem Ticket&lt;/td&gt;
    &lt;td&gt;Subject,
Invitation Ticket&lt;/td&gt;
    &lt;td&gt;Subject&lt;/td&gt;
    &lt;td&gt;This in effect allows for a Set Affiliation entry to be generated in two parts.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Rekey&lt;/td&gt;
    &lt;td&gt;Old Key,
New Key&lt;/td&gt;
    &lt;td&gt;Subject&lt;/td&gt;
    &lt;td&gt;Used by a client to replace the keying material it uses without changing the affiliation of the client. This entry is signed with the old key. This invalidates the old key for future use.&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</t>

<t>Subjects are identified in the roster log by their signing public key.</t>

<t>Each log entry includes a hash of the message that precedes it. This ensures that a log entry cannot be replayed on top of a different roster state.</t>

<t>The <eref target="http://xmpp.org/extensions/xep-0045.html#affil">owner</eref> affiliation is required to perform important tasks, like setting the room type or altering configuration options.  For setting the affiliation or state of other clients, a combination of factors determine whether an operation is valid: the affiliation of the user performing the change, the room type, and the room permissions.</t>

<section anchor="tracking-affiliations-and-states" title="Tracking Affiliations and States">

<t>The roster log becomes the source of truth for affiliations (or for client state).  This has a range of consequences, some of which result in divergence from unprotected chat or MUC.</t>

<t>The roster log is public information.  This means that affiliations and states can be seen by any client. This information is advertised to room participants in the presence advertisements, but rooms can be configured to suppress presence. Access to affiliation information for offline users (member, admin, and owner lists) is controlled.</t>

<t>The design to this point assumes that there is some functional distinction between an affiliation of Member and an affiliation of None. This is not the case in an Open or Unmoderated room. For those room types, the roster log does not need to track affiliation transitions between Member and None, though it may if the room type could change.</t>

<t>ISSUE: Is there any sense in encrypting communications when a room is open or unmoderated?  Since anyone can join, the main value is in having some knowledge about the set of clients that might have received a message. Given the high level of pseudonymity used, is even that much achievable?</t>

<t>The Outcast affiliation cannot be tracked, which makes it impossible to ban a user from an MUC. That is not a consequence of the roster log design, but a result of requiring the use of <xref target="heading=h.9var2wwipg3">pseudonyms</xref> in MUC.</t>

</section>
<section anchor="invitation-tickets" title="Invitation Tickets">

<t>An offline client or user is invited to an MUC by sending them an invitation ticket.</t>

<t>An invitation ticket contains all the information that a Set Affiliation roster log entry might have, without a subject.  That subject is provided when the ticket is redeemed.</t>

<t><list style="symbols">
  <t>Affiliation (and role)</t>
  <t>GUID</t>
  <t>A signature from a client that is authorized to make the change</t>
</list></t>

<t>Invitation tickets are bearer tokens. That means that distribution of these messages needs to use confidentiality protection, such as that provided by secure one-to-one messaging.</t>

<t>Note: It might seem obvious that an equivalent function could be provided for invitations of new clients for a bare JID. However, offline invitations for alternative clients don’t have any equivalent mechanism for confidentiality protection. The safest option here is to leave this unspecified. That forces new clients to come online before they can be invited from another client.</t>

<t>A client can revoke any unused tickets that they have sent by rekeying. Consequently, new invitations have to be issued if a client updates their keys.</t>

</section>
</section>
<section anchor="roster-state" title="Roster State">

<t>Clients process a roster log to produce their own view of the state of the roster. This ultimately results in a set of clients that are authorized to receive key advertisements.</t>

<t>Each client maintains their own view of the state of the roster for other clients and each MUC that they participate in.  This state can be recovered at any time by re-processing the roster log. Clients use this state to select the clients that keying material can be shared with. Clients also use roster state in determining whether a new roster log entry is valid.</t>

<t>A roster log can enter a broken state if an invalid entry is added. Servers are expected to validate new entries and ensure that this doesn’t happen, but it is possible that errors or malice could cause invalid entries to be recorded and distributed. Clients are required to freeze the state of a roster at the point where the last valid entry is found.</t>

</section>
<section anchor="security-limitations" title="Security Limitations">

<t>We have to assume that an attacker (in particular, the server that maintains and distributes a roster log) can affect how a roster log makes progress.</t>

<t>This can be used to an attacker’s advantage. An attacker can withhold new changes from clients, or from a subset of clients. By preventing some subset of clients from learning about changes, an attacker can freeze the state of a roster from the perspective of those clients.</t>

<t>This could potentially be used to stimulate the creation of multiple different changes from the same starting state.  The attacker might then choose to allow changes only that are favorable to it.</t>

<t>In general, this means that the progress of a roster state has to be viewed as a directed graph, not a linear sequence. The nodes of the graph correspond to states of the roster. The outbound edges from any node are the valid set of changes that might be made from that state by any agent that is currently present.</t>

<t>Given sufficient time, a server can direct progress along any edge that is presented to it. Also, the server can freeze the node that an individual client sees by refusing to forward entries to that client.</t>

<t>More opportunities are available to the server if clients rely on the server to maintain the entirety of the log state.  A client that maintains no state about a roster opens itself to the possibility that the server could set the state of the roster to any node in the directed graph, including old states.</t>

</section>
<section anchor="mitigating-attacks" title="Mitigating Attacks">

<t>The obvious protection clients can use to limit the potential for unconstrained state manipulation is remembering the state of a log. This can be limited to the last entry (or the hash of that entry), even if clients need to discard other state. This prevents roster progress from being rewound, but it cannot do anything about a server withholding entries that a client hasn’t seen.</t>

<t>The potential for attacks based on withholding log entries is a potentially serious concern. The design of XMPP naturally provides a single central controller: the server.  That central controller can provide excellent consistency, if we assume that the server chooses to present the same view of the roster log to all clients.  However, if the server is malicious, then it represents a single point of failure.</t>

<t>ISSUE: It might be that this is an acceptable condition, given the limited opportunity that the server has to affect change. An alternative design would decouple the roster management function from the message delivery function, which would allow this to be independent of the XMPP server. That opens other options, like distributed or redundant roster stores, though a decoupled design adds new error conditions for every problem it aims to address.</t>

</section>
</section>
<section anchor="pseudonymity" title="Pseudonymity">

<t>Providing end-to-end confidentiality and integrity greatly improves the privacy profile of XMPP. However, exposure of a user’s JID to a group chat server allows for a greater degree of traffic analysis. This proposes the use of a pseudonym to minimize the information that is made available to a group chat server.</t>

<t>A new service is added whereby a client can request the creation of an unlinked pseudonym. That pseudonym is a bare JID that is aliased to another bare JID. Resource identifiers can then be selected by the client so that messages routed to pseudonym can’t be linked to their primary identifier.</t>

<t>A pseudonym allows a client to join a group chat without exposing their identity to the group chat.</t>

</section>
<section anchor="identity-assertions" title="Identity Assertions">

<t>The identity of users is one of the most important pieces of confidential information in the context of a chat. Identity information need to be confidentiality protected if they transit more than one server hop. Identity is also</t>

<t>A new &lt;message&gt; payload is defined to carry identity assertions.  That assertion binds a bare JID to the signing public key used by a client to send messages.</t>

<t>The identity assertion contains only a single bit of public information: the domain name of the asserting entity.  The remainder is an opaque blob of data that is consumed by the identity provider.</t>

<t>&lt;message from=&rdquo;&hellip;” to=”&hellip;” id=”&hellip;” type=”chat”&gt;
  &lt;x xmlns=”&hellip;identity#assertion”&gt;
    &lt;domain&gt;example.com&lt;/domain&gt;
    &lt;assertion&gt;
      Gv3JuuWcMW0NZZib8pk+ZMPS4jnkmT0cFZQTPOTUM0yAktmseWAk2w
    &lt;/assertion&gt;
  &lt;/x&gt;
&lt;/message&gt;</t>

<section anchor="acquiring-identity-assertions" title="Acquiring Identity Assertions">

<t>An identity assertion is acquired from the domain that is responsible for the JID (that is usually the client’s own server) by sending a query to that server. The server uses the client’s authentication credentials, which are usually bound to a connection, to determine if the client owns the identifier.</t>

<t>Here, &ldquo;user@example.com&rdquo; attempts to</t>

<t>&lt;iq from=&rdquo;user@example.com/resource” to=”example.com” id=”&hellip;” type=”get”&gt;
  &lt;x xmlns=”&hellip;identity”&gt;
    &lt;publicKey&gt;&hellip;&lt;/publicKey&gt;
  &lt;/x&gt;
&lt;/iq&gt;</t>

<t>The information that is signed is the signing key that the client intends to bind to their identity.</t>

<t>The assertion that the server generates will ultimately be consumed by the server that generated it, so it can be completely opaque. However, it should contain enough information for the server to identify the JID of the client that it relates to, as well as verify its authenticity.</t>

<t>&lt;iq from=&rdquo;example.com” to=”user@example.com/resource” id=”&hellip;” type=”result”&gt;
  &lt;x xmlns=”&hellip;identity#assertion”&gt;
    &lt;domain&gt;example.com&lt;/domain&gt;
    &lt;assertion&gt;
      Gv3JuuWcMW0NZZib8pk+ZMPS4jnkmT0cFZQTPOTUM0yAktmseWAk2w
    &lt;/assertion&gt;
  &lt;/x&gt;
&lt;/iq&gt;</t>

<t>The assertion might also include limits on validity, such as an expiration time, as dictated by server policy.</t>

</section>
<section anchor="validating-identity-assertions" title="Validating Identity Assertions">

<t>ISSUE: This validation mechanism relies on transitive trust in the server of the client making the query. Confidentiality protection seems like the right thing here.  Which is a second case for server-to-client confidentiality.</t>

<t>Clients that receive the identity assertion can then query the server that issued it and request the identity that it contains. The server validates the assertion, and either generates an error, or a message containing the identity.</t>

<t>The query includes the assertion:</t>

<t>&lt;iq from=&rdquo;other@example.net/check” to=”example.com” id=”&hellip;” type=”get”&gt;
  &lt;x xmlns=”&hellip;identity#assertion”&gt;
    &lt;domain&gt;example.com&lt;/domain&gt;
    &lt;assertion&gt;
      Gv3JuuWcMW0NZZib8pk+ZMPS4jnkmT0cFZQTPOTUM0yAktmseWAk2w
    &lt;/assertion&gt;
  &lt;/x&gt;
&lt;/iq&gt;</t>

<t>A successful response includes the identity of the client, and the public key that was asserted.</t>

<t>&lt;iq from=&rdquo;example.com” to=”other@example.net/check” id=”&hellip;” type=”get”&gt;
  &lt;x xmlns=”&hellip;identity#identity”&gt;
    &lt;identity&gt;user@example.com&lt;/identity&gt;
    &lt;publicKey&gt;&hellip;&lt;/publicKey&gt;
  &lt;/x&gt;
&lt;/iq&gt;</t>

<t>A client receiving this response checks that the domain part of the identifier matches the server identity. Once this check is complete, the identity can be associated with the public key. All messages sent with that public key can thereafter be attributed to the identifier. Clients might also provide indicators that the sender of authenticated messages has been verified.</t>

</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC2119;


    </references>




  </back>
</rfc>

